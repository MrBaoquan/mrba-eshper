import r from"moment";function t(r,...t){return t.reduce(((r,t,o)=>r.replace(`{${o}}`,t)),r)}function o(r,t,...e){if("function"==typeof r)return Reflect.apply(r,t,e);if("object"==typeof r){let n=Reflect.get(r,t,e);if(void 0===n)return;return o(n,r,...e)}return null}function e(r,t,o){let e=0,n=()=>{++e>=r.length&&o()};for(let o of r)t(o,n)}class n{static Register(r){r.info&&(this.info=r.info),r.warn&&(this.warn=r.warn),r.error&&(this.error=r.error)}static Log(r,...t){n.doLogger(this.info,r,...t)}static Warn(r,...t){n.doLogger(this.warn,r,...t)}static Error(r,...t){n.doLogger(this.error,r,...t)}static doLogger(t,o,...e){let n=r().format("YYYY-MM-DD HH:mm:ss.SSS")+": ";"string"==typeof o?t(n+o,...e):t(n,o)}}n.info=console.log,n.warn=console.warn,n.error=console.error;const c=Symbol(),i=r=>new Proxy(r,{construct:(r,t,o)=>r.prototype!==o.prototype?Reflect.construct(r,t,o):(r[c]||(r[c]=Reflect.construct(r,t,o)),r[c])});function f(r){return null!=r}export{o as CallFunction,t as FormatString,n as Logger,e as ParallelForEach,c as SINGLETON_KEY,f as isset,i as singleton};
