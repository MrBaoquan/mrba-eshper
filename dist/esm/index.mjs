import t from"moment";function r(t){return null!=t}function o(t,...r){return r.reduce(((t,r,o)=>t.replace(`{${o}}`,r)),t)}function e(t,o,...n){if(!r(t))return null;if("function"==typeof t)return Reflect.apply(t,o,n);if("object"==typeof t){let i=Reflect.get(t,o,n);if(!r(i))return;return e(i,t,...n)}return null}function n(t,r,o){let e=0,n=()=>{++e>=t.length&&o()};for(let o of t)r(o,n)}class i{static Enable(){this.logable=!0}static Disable(){this.logable=!1}static Register(t){t.info&&(this.info=t.info),t.warn&&(this.warn=t.warn),t.error&&(this.error=t.error)}static Log(t,...r){i.doLogger(this.info,t,...r)}static Warn(t,...r){i.doLogger(this.warn,t,...r)}static Error(t,...r){i.doLogger(this.error,t,...r)}static doLogger(r,o,...e){if(!this.logable)return;let n=t().format("YYYY-MM-DD HH:mm:ss.SSS")+": ";"string"==typeof o?r(n+o,...e):r(n,o)}}i.info=console.log,i.warn=console.warn,i.error=console.error,i.logable=!0;const l=Symbol(),c=t=>new Proxy(t,{construct:(t,r,o)=>t.prototype!==o.prototype?Reflect.construct(t,r,o):(t[l]||(t[l]=Reflect.construct(t,r,o)),t[l])});export{e as CallFunction,o as FormatString,i as Logger,n as ParallelForEach,l as SINGLETON_KEY,r as isset,c as singleton};
